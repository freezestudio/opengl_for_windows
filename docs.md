# freegl文档

## 概述

不同于我们日常使用文字（文本）来表示对象的名字，`OpenGL`使用无符号整数表示对象名。
因此对于`OpenGL`对象，如果它大于`0`，则表示某个对象存在。（某些对象比如`FBO`、`TFO`等，`0`表示默认对象）

`OpenGL`常用的对象有顶点数组对象(`VAO`)、顶点缓存对象(`VBO`)、索引缓存对象(`EBO`)、全局统一变量缓冲对象(`UBO`)、
缓冲区对象(`FBO`),渲染缓冲区对象(`RBO`)、TransformFeedback(`TFO`)、纹理对象(`Texture`)、着色器(`Shader`)及着色器程序(`Program`)对象等。
它们的创建与使用是类似的。都是从`OpenGL`内部返回表示某对象的无符号整数值。使用`OpenGL`提供的接口来间接操作这些对象。

我们以常用的`VAO`和`VBO`为例，来观察它们的操作。
生成一个或一系列`VBO`的操作如下：

```c++
//一个
GLuint vao;
glGenBuffers(1,&vao);

//多个
GLuint vao[n];
glGenBuffers(n,vao);
```

使用它们时，需要先将它们绑定为当前对象。操作完成后，(可选地)解绑该对象，或者绑定另一个。

```c++
//指定绑定对象的类型，和对象名。（对象名字就是创建对象后返回的数值）
glBindBuffer(GL_ARRAY_BUFFER,vao);
//针对此对象的一些操作
// ...
//绑定到一个无名字的对象，也就是解除了之前对象的绑定。
glBindBuffer(GL_ARRAY_BUFFER,0);
```

因此，我们需要将这些值封装起来，让它们看起来像是真正的对象，而不是无意义的整数值。

```c++
struct opengl_object
{
    GLuint object_id;
};
```

考察上面这个结构，它还不能完整地表达`OpenGL`对象的信息。我们需要

1. 不同类型之间做出区分
1. 同类型之间不同对象的区分

应用C++模板类，恰好可以完成以上任务。

```c++
template<typename T>
struct opengl_object
{
    GLuint object_id;
};
```

## OpenGL对象

一个OpenGL对象是一个包含一些状态信息的OpenGL结构。当它位于OpenGL上下文中时，
OpenGL对象的状态会映射到OpenGL上下文中。因此，改变上下文的状态，也会使这个状态保存到OpenGL对象中。
并且，作用于这个上下文状态的函数将使用存储在该对象中的状态。

OpenGL被定义为“状态机”。 各种API调用改变OpenGL状态，查询该状态的一部分，
或者使OpenGL使用其当前状态来呈现某些东西。

对象始终是状态的容器。 每种特定类型的对象都是由它所包含的特定状态来定义的。
OpenGL对象是一种封装特定的状态组并将其全部更改为一个函数调用的方法。

请记住：这只是OpenGL规范定义的。 如何在驱动中实际实施这些对象是另一回事。 
但这不是你需要担心的; 重要的是，规范所定义的对象和状态是如何相互作用的。

### 对象的创建与销毁

要创建一个对象，你需要生成对象的名字（一个整数）。这将创建对该对象的引用。但是，这不一定会创建对象的状态数据。
对于大多数对象类型，对象只有在首先绑定到上下文时才会包含其默认状态; 直到绑定，试图使用它将失败。
但Program Pipeline对象和Sampler对象除外。

生成对象名称的函数的形式为glGen*，其中*是复数形式的对象类型。这种类型的所有功能都具有相同的签名：

```c
void glGen*(GLsizei n​, GLuint *objects​);
```
该函数生成给定类型的n个对象，并将它们存储在objects参数给出的数组中。 这允许您通过一次调用创建多个对象。

一个对象名称总是一个GLuint。 这些名字不是指针，也不应该假设它们是指针。 它们是引用，标识对象的数字。 
它们可以是除0以外的任何32位无符号整数。对象编号0是为特殊用例保留的; 详情见下文。

一旦你不再使用一个对象，你应该删除它。 这个函数的形式是glDelete*，使用与之前相同的对象类型。 这些功能有这个签名：

```c
void glDelete*(GLsizei n​, const GLuint *objects​);
```

和glGen*函数类似，只不过是用删除替代了创建。 任何不是有效对象或对象0的值都将被忽略。

当OpenGL对象被删除时，它们的名字不再被认为是有效的。 
在此调用之后，随后的glGen*调用可能会或可能不会重复使用先前删除的名称; 你不应该做任何假设。

#### 删除与解除绑定

当一个对象被删除时，如果该对象绑定到当前上下文（并且注意这只适用于当前上下文），那么该对象将从绑定到上下文的所有绑定中解除绑定。

> *注意：
> 这会影响“绑定”，而不是“附件”。对象绑定到上下文，而附件引用另一个对象。附件不会因这个调用而切断。

此外，如果对象attached到任何容器对象，并且该对象本身绑定到当前上下文，则该对象将从容器对象unattached。
如果attached到未绑定到当前上下文的对象，则附件不会中断。

有些对象可以以不同寻常的方式绑定到上下文中。这些方式包括但不限于：

1. 缓冲区对象通过glBindBufferRange或其等价物绑定到索引目标。
1. 作为图像绑定的纹理。

在OpenGL 4.4及以下版本中，当对象被删除时，这些绑定没有被取消。这些版本中唯一被取消的绑定是通过调用对象类型的基本glBind*函数可以撤销的绑定。

所以如果你调用了glBindBufferRange（GL_UNIFORM_BUFFER，...）然后删除那个缓冲区，
就好像调用了glBindBuffer（GL_UNIFORM_BUFFER，0）。这不会从索引目标中解除绑定。

即使从这些不寻常的绑定方法，OpenGL 4.5及以上版本也将解除绑定。这些“绑定”被重置为默认状态。
再次回想一下，这只发生在当前的OpenGL上下文中。

#### 删除单独的对象

在一个对象上调用glDelete*并不能保证立即销毁该对象的内容。此外，它甚至不保证立即销毁对象的名称，因为对象名称在删除后仍然可以使用。
如果一个对象在被删除后仍然处于“使用中”状态，那么该对象将在OpenGL实现中保持活动状态。

一个对象是“在使用”，如果：

1. 这是一个上下文。这不一定是当前的，因为删除它会自动将其从导致删除的上下文中解除绑定。虽然请记住GL 4.4和之前的非标准绑定点的注意事项。
1. 它被附加到一个容器对象。

所以如果一个Texture被附加到一个没有绑定到上下文的Framebuffer对象上，FBO在删除纹理之后仍然可以正常工作。
只有当FBO被删除或者新的纹理附件替换旧的纹理时，纹理才会被完全删除。

请注意，名称仍然可以通过OpenGL API检测到。
您可以调用glGetFramebufferAttachmentParameteriv（GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME）来获取对象的名称。
但是，这个名字仍然被认为是未使用的，所以不要用它来做任何事情。

注意：有些实现不能正确实现最后一部分。所以真的不要用这个。

### 对象的使用

由于OpenGL中的对象被定义为状态集合，所以要修改对象，必须先将它们绑定到OpenGL上下文。
将对象绑定到上下文会导致其中的状态被设置为当前上下文的状态。
这意味着任何改变被该对象支配的状态的函数都将简单地改变对象内的状态，从而保持该状态。

绑定新生成的对象名称将为该对象创建新的状态。在某些情况下，它首先被绑定的目标（见下文）会影响该对象的新创建状态的属性。

不同的对象有不同的绑定功能。他们确实共享一个命名约定和一般参数：

```c
void glBind*（GLenum target，GLuint object）;
```

*是对象的类型，object是要绑定的对象。

target是不同的对象类型不同的地方。有些对象可以绑定到上下文中的多个目标，而其他的只能绑定到一个特定的地方。
例如，可以将缓冲对象绑定为数组缓冲区，索引缓冲区，像素缓冲区，变换缓冲区或其他各种可能性。

不同的目标有不同的绑定。所以你可以绑定一个缓冲区对象作为一个顶点属性数组，以及一个不同的缓冲区对象作为索引缓冲区。

如果一个对象绑定到另一个对象已经绑定的位置，则先前绑定的对象将被解除绑定。

#### 0对象

GLuint值0被OpenGL对象特别处理。但是，有些对象以不同的方式对待它。0将永远不会被glGen*函数返回。

对于大多数对象类型，对象0非常类似于NULL指针：它不是一个对象。如果将0绑定到这些对象类型，则尝试使用该绑定对象进行渲染将失败。

对于某些对象，对象0代表一种“默认对象”。纹理具有默认纹理。但是，默认的纹理使用非常复杂;纹理对象0在技术上表示多个默认纹理。
此外，默认纹理不能用于常规纹理对象可以的许多方面。例如，您不能将它们的图像附加到FBO。因此，强烈建议您将纹理0视为不存在的纹理。

对于帧缓冲区，对象0表示默认帧缓冲区。它与相应的Framebuffer Object相比具有相似的状态，但是它拥有与自己的图像名称完全不同的一组图像。
此外，这些图像不能attached/detatched;这意味着许多FBO特定的接口不能在对象0上工作。
即使这样，图像属性查询函数也可以在对象0上工作，就像一般的帧缓冲接口函数一样。

> **建议：** 
> 除帧缓冲区对象外，应将对象0视为非功能对象。即使一个对象类型有一个有效的对象0，你也应该像对待它一样对待它。
  像C/C++中的NULL指针那样对待它;你可以把它存储在一个指针中，但是你不能使用那个指针，除非你把一个真正的值放在那里。

### 多绑定

许多对象类型可以绑定到特定的多个目标。因此，能够将一组对象同时绑定到一系列目标是有用的。

重要的是要注意，这些多绑定表单中的很多只能绑定使用该对象，而不是为了修改它们。

这些功能和单绑定功能之间的一个主要区别是这个。这些函数都需要绑定对象的数组。
如果该数组中的某个对象不能被绑定，如果将其与单个调用绑定会导致某种OpenGL错误，则该对象的绑定将失败，并返回GL_INVALID_OPERATION。

不同之处在于几乎所有其他的OpenGL函数都会失败并且不会产生任何影响。
相比之下，多重绑定函数仍然有效果。如果数组中的某个特定对象由于某种原因而无法绑定，则可以绑定的其余对象仍将被绑定。
只有绑定到特定编号的绑定点才会失败。即使其中一个对象不能被绑定，multibind函数仍然会发出适当的错误。

请注意，这仅适用于由于未绑定特定缓冲区或特定缓冲区的参数不正确而导致的错误。
由于无效的缓冲区绑定范围等导致的错误将不会改变任何绑定。

绑定这些函数的对象数组可以是NULL。如果是这样，那么它将绑定0到范围内所有编号的目标。
这使得在一个范围内的所有东西都容易解绑。

可以多重绑定的对象，以及允许多重绑定的具体用途如下。以下链接将提供有关这些多重绑定功能的详细信息：

1. 将缓冲区对象绑定到其中一个索引缓冲区绑定目标。
1. 缓冲区对象在顶点数据中绑定到单独的属性缓冲区。
1. 纹理和采样器对象被GLSL采样器使用。
1. 图像加载/存储操作使用的纹理。

### 共享对象

您可以创建多个OpenGL上下文。这是有用的，因为当前GL上下文是线程特定的。
通常情况下，每个环境都是完全独立的。一个人做任何事都不能影响其他人。

但是，在上下文创建时，您可以创建一个与另一个现有上下文共享对象的上下文。
这意味着您可以在另一个上下文中使用一个上下文中创建的对象

不是所有的对象类型都可以在上下文之间共享。包含对其他对象的引用的对象不能共享。
所有其他对象类型都可以共享。这包括不遵循OpenGL对象模型的GLSL对象和同步对象。

请注意，在一个上下文中对对象进行的状态更改不一定会立即在另一个上可见。
有特定的规则来管理对象状态数据的可见性。如果您正在使用线程，则需要自行进行一些同步操作，
以确保在尝试在另一个上下文中使用这些更改之前，已经在一个上下文中进行了更改。

### 对象类型

对象可以分为两个不同的类别：常规对象和容器对象。 这是常规对象的列表。

1. 缓冲区对象
1. 查询对象
1. 渲染缓冲区对象
1. 取样器对象
1. 纹理对象

#### 容器对象

1. Framebuffer对象
1. 编程管道对象
1. 转换反馈对象
1. 顶点数组对象

### 对象的名字

OpenGL对象以及诸如程序对象和同步对象之类的非标准对象是非常有用的。 
但是，他们的名字是不直观的; 它们只是数字（或者在同步对象的情况下是指针）。 
而且，这些数字是由系统定义的，而不是由用户定义的。 这使得对象的调试变得困难。

但是，OpenGL有一个机制将任意字符串名称与任何对象关联起来。 
这也允许系统生成的消息能够通过字符串名称来讨论对象。 设置对象名称的函数是：

```c
void glObjectLabel(GLenum identifier​, GLuint name​, GLsizei length​, const char * label​);

void glObjectPtrLabel(void * ptr​, GLsizei length​, const char * label​);
```

第一个函数用于设置所有使用GLuints作为其对象类型的对象。 
这意味着所有的OpenGL对象，以及所有的程序对象类型。 第二个函数设置同步对象的名称。

对于基于GLuint的对象，单独使用对象名称不足以识别对象，因为不同对象类型的两个对象可能具有相同的GLuint名称。 
因此，该类型由identifier参数指定，该参数必须是以下枚举器之一。

|identifier|Object type|
|-|-|
GL_BUFFER	|Buffer Object
GL_SHADER	|Shader Object
GL_PROGRAM	|Program Object
GL_VERTEX_ARRAY	|Vertex Array Object
GL_QUERY	|Query Object
GL_PROGRAM_PIPELINE	|Program Pipeline Object
GL_TRANSFORM_FEEDBACK	|Transform Feedback Object
GL_SAMPLER	|Sampler Object
GL_TEXTURE	|Texture Object
GL_RENDERBUFFER	|Renderbuffer Object
GL_FRAMEBUFFER	|Framebuffer Object

length指定了字符串标签的长度，该长度必须小于GL_MAX_LABEL_LENGTH（不小于256）。

要检索对象的名称，请使用以下函数：

```c
void glGetObjectLabel(GLenum identifier​, GLuint name​, GLsizei bufSize​, GLsizei * length​, char * label​);

void glGetObjectPtrLabel(void * ptr​, GLsizei bufSize​, GLsizei * length​, char * label​);
```

bufSize是标签中的总字节数; 该函数不会将超过这么多的字节（包括一个空终止符）复制到标签中。 
如果length不是NULL，那么函数将存储写入缓冲区的字符数（包括NULL指针）。 
如果标签为NULL，那么字符串的总长度将被复制为长度。 如果两者都是NULL，则会导致错误。

### 非标准的对象

以下是“对象”，但是它们并不遵循本页面上为OpenGL对象所规定的标准约定：

1. 同步对象
1. 着色器和程序对象
   1. 除了遵循OpenGL对象约定的程序管道对象之外。

## 常见问题

### 面向对象语言问题



