# OpenGL对象

一个`OpenGL`对象是一个包含一些状态信息的`OpenGL`结构。当它位于`OpenGL`上下文中时，
`OpenGL`对象的状态会映射到`OpenGL`上下文中。因此，改变上下文的状态，也会使这个状态保存到`OpenGL`对象中。
并且，作用于这个上下文状态的函数将使用存储在该对象中的状态。

`OpenGL`被定义为“状态机”。 各种`API`调用改变`OpenGL`状态，查询该状态的一部分，或者使`OpenGL`使用其当前状态来呈现某些东西。

对象始终是状态的容器。 每种特定类型的对象都是由它所包含的特定状态来定义的。`OpenGL`对象是一种封装特定的状态组并将其全部更改为一个函数调用的方法。

请记住：这只是`OpenGL`规范定义的。 如何在驱动中实际实施这些对象是另一回事。 但这不是你需要担心的; 重要的是，规范所定义的对象和状态是如何相互作用的。

## 对象的创建与销毁

要创建一个对象，你需要生成对象的名字（一个整数）。这将创建对该对象的引用。但是，这不一定会创建对象的状态数据。对于大多数对象类型，对象只有在首先绑定到上下文时才会包含其默认状态; 直到绑定，试图使用它将失败。但`Program Pipeline`对象和`Sampler`对象除外。

生成对象名称的函数的形式为`glGen*`，其中`*`是复数形式的对象类型。这种类型的所有功能都具有相同的签名：

```c
void glGen*(GLsizei n​, GLuint *objects​);
```

该函数生成给定类型的`n`个对象，并将它们存储在`objects`参数给出的数组中。 这允许您通过一次调用创建多个对象。

一个对象名称总是一个`GLuint`。 这些名字不是指针，也不应该假设它们是指针。 它们是引用，标识对象的数字。 
它们可以是除`0`以外的任何`32`位无符号整数。对象编号`0`是为特殊用例保留的; 详情见下文。

一旦你不再使用一个对象，你应该删除它。 这个函数的形式是`glDelete*`，使用与之前相同的对象类型。 这些功能有这个签名：

```c
void glDelete*(GLsizei n​, const GLuint *objects​);
```

和`glGen*`函数类似，只不过是用`Delete`替代了`Gen`。 任何不是有效对象或对象`0`的值都将被忽略。

当`OpenGL`对象被删除时，它们的名字不再被认为是有效的。 
在此调用之后，随后的`glGen*`调用可能会或可能不会重复使用先前删除的名称; 你不应该做任何假设。

### 删除与解除绑定

当一个对象被删除时，如果该对象绑定到当前上下文（并且注意这只适用于当前上下文），那么该对象将从绑定到上下文的所有绑定中解除绑定。

> **注意：**
> 这会影响“绑定”，而不是“附件”。对象绑定到上下文，而附件引用另一个对象。附件不会因这个调用而切断。

此外，如果对象`attached`到任何容器对象，并且该对象本身绑定到当前上下文，则该对象将从容器对象`unattached`。如果`attached`到未绑定到当前上下文的对象，则附件不会中断。

有些对象可以以不同寻常的方式绑定到上下文中。这些方式包括但不限于：

1. 缓冲区对象通过`glBindBufferRange`或其等价物绑定到索引目标。
1. 作为图像绑定的纹理。

在`OpenGL 4.4`及以下版本中，当对象被删除时，这些绑定没有被取消。这些版本中唯一被取消的绑定是通过调用对象类型的基本`glBind*`函数可以撤销的绑定。

所以如果你调用了`glBindBufferRange(GL_UNIFORM_BUFFER，...)`然后删除那个缓冲区，就好像调用了`glBindBuffer(GL_UNIFORM_BUFFER，0)`。这不会从索引目标中解除绑定。

即使从这些不寻常的绑定方法，`OpenGL 4.5`及以上版本也将解除绑定。这些“绑定”被重置为默认状态。再次回想一下，这只发生在当前的`OpenGL`上下文中。

### 删除单独的对象

在一个对象上调用`glDelete*`并不能保证立即销毁该对象的内容。此外，它甚至不保证立即销毁对象的名称，因为对象名称在删除后仍然可以使用。如果一个对象在被删除后仍然处于“使用中”状态，那么该对象将在`OpenGL`实现中保持活动状态。

一个对象是“在使用”，如果：

1. 这是一个上下文。这不一定是当前的，因为删除它会自动将其从导致删除的上下文中解除绑定。虽然请记住`GL 4.4`和之前的非标准绑定点的注意事项。
1. 它被附加到一个容器对象。

所以如果一个`Texture`被附加到一个没有绑定到上下文的`Framebuffer`对象上，`FBO`在删除纹理之后仍然可以正常工作。只有当`FBO`被删除或者新的纹理附件替换旧的纹理时，纹理才会被完全删除。

请注意，名称仍然可以通过`OpenGL API`检测到。您可以调用`glGetFramebufferAttachmentParameteriv(GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME)`来获取对象的名称。但是，这个名字仍然被认为是未使用的，所以不要用它来做任何事情。

> **注意：** 有些实现不能正确实现最后一部分。所以真的不要用这个。

## 对象的使用

由于`OpenGL`中的对象被定义为状态集合，所以要修改对象，必须先将它们绑定到`OpenGL`上下文。将对象绑定到上下文会导致其中的状态被设置为当前上下文的状态。这意味着任何改变被该对象支配的状态的函数都将简单地改变对象内的状态，从而保持该状态。

绑定新生成的对象名称将为该对象创建新的状态。在某些情况下，它首先被绑定的目标（见下文）会影响该对象的新创建状态的属性。

不同的对象有不同的绑定功能。他们确实共享一个命名约定和一般参数：

```c
void glBind*（GLenum target，GLuint object）;
```

`*`是对象的类型，`object`是要绑定的对象。

`target`是不同的对象类型不同的地方。有些对象可以绑定到上下文中的多个目标，而其他的只能绑定到一个特定的地方。例如，可以将缓冲对象绑定为数组缓冲区，索引缓冲区，像素缓冲区，变换缓冲区或其他各种可能性。

不同的目标有不同的绑定。所以你可以绑定一个缓冲区对象作为一个顶点属性数组，以及一个不同的缓冲区对象作为索引缓冲区。

如果一个对象绑定到另一个对象已经绑定的位置，则先前绑定的对象将被解除绑定。

### 0对象

`GLuint`值`0`被`OpenGL`对象特别处理。但是，有些对象以不同的方式对待它。`0`将永远不会被`glGen*`函数返回。

对于大多数对象类型，对象`0`非常类似于`NULL`指针：它不是一个对象。如果将`0`绑定到这些对象类型，则尝试使用该绑定对象进行渲染将失败。

对于某些对象，对象`0`代表一种“默认对象”。纹理具有默认纹理。但是，默认的纹理使用非常复杂;纹理对象`0`在技术上表示多个默认纹理。

此外，默认纹理不能用于常规纹理对象可以的许多方面。例如，您不能将它们的图像附加到`FBO`。因此，强烈建议您将纹理`0`视为不存在的纹理。

对于帧缓冲区，对象`0`表示默认帧缓冲区。它与相应的`Framebuffer Object`相比具有相似的状态，但是它拥有与自己的图像名称完全不同的一组图像。

此外，这些图像不能`attached/detatched`;这意味着许多`FBO`特定的接口不能在对象`0`上工作。即使这样，图像属性查询函数也可以在对象`0`上工作，就像一般的帧缓冲接口函数一样。

> **建议：**
> 除帧缓冲区对象外，应将对象`0`视为非功能对象。即使一个对象类型有一个有效的对象`0`，你也应该像`C/C++`中的`NULL`指针那样对待它;你可以把它存储在一个指针中，但是你不能使用那个指针，除非你把一个真正的值放在那里。

## 多绑定

许多对象类型可以绑定到特定的多个目标。因此，能够将一组对象同时绑定到一系列目标是有用的。

重要的是要注意，这些多绑定表单中的很多只能绑定使用该对象，而不是为了修改它们。

这些功能和单绑定功能之间的一个主要区别是这个。这些函数都需要绑定对象的数组。如果该数组中的某个对象不能被绑定，如果将其与单个调用绑定会导致某种`OpenGL`错误，则该对象的绑定将失败，并返回`GL_INVALID_OPERATION`。

不同之处在于几乎所有其他的`OpenGL`函数都会失败并且不会产生任何影响。相比之下，多重绑定函数仍然有效果。如果数组中的某个特定对象由于某种原因而无法绑定，则可以绑定的其余对象仍将被绑定。只有绑定到特定编号的绑定点才会失败。即使其中一个对象不能被绑定，`multibind`函数仍然会发出适当的错误。

请注意，这仅适用于由于未绑定特定缓冲区或特定缓冲区的参数不正确而导致的错误。由于无效的缓冲区绑定范围等导致的错误将不会改变任何绑定。

绑定这些函数的对象数组可以是NULL。如果是这样，那么它将绑定`0`到范围内所有编号的目标。这使得在一个范围内的所有东西都容易解绑。

可以多重绑定的对象，以及允许多重绑定的具体用途如下。以下链接将提供有关这些多重绑定功能的详细信息：

1. 将缓冲区对象绑定到其中一个索引缓冲区绑定目标。
1. 缓冲区对象在顶点数据中绑定到单独的属性缓冲区。
1. 纹理和采样器对象被`GLSL`采样器使用。
1. 图像加载/存储操作使用的纹理。

## 共享对象

您可以创建多个`OpenGL`上下文。这是有用的，因为当前`GL`上下文是线程特定的。通常情况下，每个环境都是完全独立的。一个人做任何事都不能影响其他人。

但是，在上下文创建时，您可以创建一个与另一个现有上下文共享对象的上下文。这意味着您可以在另一个上下文中使用一个上下文中创建的对象

不是所有的对象类型都可以在上下文之间共享。包含对其他对象的引用的对象不能共享。所有其他对象类型都可以共享。这包括不遵循`OpenGL`对象模型的`GLSL`对象和同步对象。

请注意，在一个上下文中对对象进行的状态更改不一定会立即在另一个上可见。有特定的规则来管理对象状态数据的可见性。如果您正在使用线程，则需要自行进行一些同步操作，以确保在尝试在另一个上下文中使用这些更改之前，已经在一个上下文中进行了更改。

## 对象类型

对象可以分为两个不同的类别：常规对象和容器对象。 这是常规对象的列表。

1. 缓冲区对象
1. 查询对象
1. 渲染缓冲区对象
1. 取样器对象
1. 纹理对象

### 容器对象

1. `Framebuffer`对象
1. 编程管道对象
1. 转换反馈对象
1. 顶点数组对象

## 对象的名字

`OpenGL`对象以及诸如程序对象和同步对象之类的非标准对象是非常有用的。 但是，他们的名字是不直观的; 它们只是数字（或者在同步对象的情况下是指针）。而且，这些数字是由系统定义的，而不是由用户定义的。 这使得对象的调试变得困难。

但是，`OpenGL`有一个机制将任意字符串名称与任何对象关联起来。 这也允许系统生成的消息能够通过字符串名称来讨论对象。 设置对象名称的函数是：

```c
void glObjectLabel(GLenum identifier​, GLuint name​, GLsizei length​, const char * label​);

void glObjectPtrLabel(void * ptr​, GLsizei length​, const char * label​);
```

第一个函数用于设置所有使用`GLuints`作为其对象类型的对象。这意味着所有的`OpenGL`对象，以及所有的程序对象类型。 第二个函数设置同步对象的名称。

对于基于`GLuint`的对象，单独使用对象名称不足以识别对象，因为不同对象类型的两个对象可能具有相同的`GLuint`名称。 

因此，该类型由`identifier`参数指定，该参数必须是以下枚举器之一。

|identifier|Object type|
|-|-|
GL_BUFFER|Buffer Object
GL_SHADER|Shader Object
GL_PROGRAM|Program Object
GL_VERTEX_ARRAY|Vertex Array Object
GL_QUERY|Query Object
GL_PROGRAM_PIPELINE|Program Pipeline Object
GL_TRANSFORM_FEEDBACK|Transform Feedback Object
GL_SAMPLER|Sampler Object
GL_TEXTURE|Texture Object
GL_RENDERBUFFER|Renderbuffer Object
GL_FRAMEBUFFER|Framebuffer Object

`length`指定了字符串标签的长度，该长度必须小于`GL_MAX_LABEL_LENGTH`（不小于`256`）。

要检索对象的名称，请使用以下函数：

```c
void glGetObjectLabel(GLenum identifier​, GLuint name​, GLsizei bufSize​, GLsizei * length​, char * label​);

void glGetObjectPtrLabel(void * ptr​, GLsizei bufSize​, GLsizei * length​, char * label​);
```

`bufSize`是标签中的总字节数; 该函数不会将超过这么多的字节（包括一个空终止符）复制到标签中。 如果`length`不是`NULL`，那么函数将存储写入缓冲区的字符数（包括`NULL`指针）。 如果标签为`NULL`，那么字符串的总长度将被复制为长度。 如果两者都是`NULL`，则会导致错误。

## 非标准的对象

以下是“对象”，但是它们并不遵循本页面上为`OpenGL`对象所规定的标准约定：

1. 同步对象
1. 着色器和程序对象
   * 除了遵循`OpenGL`对象约定的程序管道对象之外。

## 缓冲区对象

缓冲区对象是OpenGL对象，用于存储由OpenGL上下文（也称为GPU）分配的未格式化内存数组。 这些可以用来存储顶点数据，从图像或帧缓冲器检索的像素数据，以及其他各种各样的东西。

### 创建

缓冲区对象是OpenGL对象 ; 他们因此遵循规则的OpenGL对象的所有规则。要创建一个缓冲区对象，可以调用`glGenBuffers`。删除它们使用`glDeleteBuffers`。这些使用标准的`Gen/Delete`范例作为大多数`OpenGL`对象。

与标准的OpenGL对象范例一样，这只会创建对象的名称，即对该对象的引用。要设置其内部状态，您必须将其绑定到上下文。您可以使用以下API来执行此操作：

```c
void glBindBuffer(enum target，uint bufferName)
```

`target`定义你打算如何使用缓冲区对象的这种结合。当你刚刚创建，填充缓冲区对象的数据，或两者，你使用的目标在技术上并不重要。

缓冲区对象拥有任意大小的线性内存阵列。该内存必须先分配，然后才能上传或使用。有两种方法为缓冲区对象分配存储：可变或不可变。为缓冲区分配不可变的存储将改变与缓冲区对象的交互方式。

#### 不可变的存储

##### 不可变的访问方法

#### 可变的存储

##### 缓冲区对象的使用

### 数据规范

#### 清除

#### 复制

#### 映射

##### 对齐

##### 缓冲区腐坏

##### 持久映射

##### 性能问题

### 无效

### 流媒体

### 一般使用

#### 绑定索引目标

#### 多目标和索引目标

### 缓冲区对象流

### 像素缓冲区对象

## 纹理

### 采样对象

### 图像格式

### 像素传输操作

### 立方体纹理

### 纹理数组

### 纹理缓存

## 异步查询对象

## 渲染缓冲区对象

### 缺省缓冲区

### 渲染缓存对象

## 非传统对象

### 同步对象

### 着色器和程序对象